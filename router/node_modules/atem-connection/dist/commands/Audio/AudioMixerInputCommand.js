"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const AbstractCommand_1 = require("../AbstractCommand");
const __1 = require("../..");
class AudioMixerInputCommand extends AbstractCommand_1.default {
    constructor() {
        super(...arguments);
        this.rawName = 'CAMI';
    }
    serialize() {
        const buffer = Buffer.alloc(12);
        buffer.writeUInt8(this.flag, 0);
        buffer.writeUInt16BE(this.index, 2);
        buffer.writeUInt8(this.properties.mixOption || 0, 4);
        buffer.writeUInt16BE(__1.Util.DecibelToUInt16BE(this.properties.gain || 0), 6);
        buffer.writeInt16BE(__1.Util.BalanceToInt(this.properties.balance || 0), 8);
        return buffer;
    }
}
exports.AudioMixerInputCommand = AudioMixerInputCommand;
AudioMixerInputCommand.MaskFlags = {
    mixOption: 1 << 0,
    gain: 1 << 1,
    balance: 1 << 2
};
class AudioMixerInputUpdateCommand extends AbstractCommand_1.default {
    constructor() {
        super(...arguments);
        this.rawName = 'AMIP';
    }
    deserialize(rawCommand) {
        this.index = rawCommand.readUInt16BE(0);
        this.properties = {
            sourceType: rawCommand.readUInt8(2),
            portType: rawCommand.readUInt8(7),
            mixOption: rawCommand.readUInt8(8),
            gain: __1.Util.UInt16BEToDecibel(rawCommand.readUInt16BE(10)),
            balance: __1.Util.IntToBalance(rawCommand.readInt16BE(12))
        };
    }
    applyToState(state) {
        // const channel = state.audio.getChannel(this.index)
        state.audio.channels[this.index] = Object.assign(Object.assign({}, state.audio.channels[this.index]), this.properties);
        return `audio.channels.${this.index}`;
    }
}
exports.AudioMixerInputUpdateCommand = AudioMixerInputUpdateCommand;
//# sourceMappingURL=AudioMixerInputCommand.js.map