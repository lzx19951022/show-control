"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const dgram_1 = require("dgram");
const events_1 = require("events");
const util_1 = require("util");
const atemUtil_1 = require("./atemUtil");
const enums_1 = require("../enums");
const NanoTimer = require("nanotimer");
class AtemSocketChild extends events_1.EventEmitter {
    constructor(options = {}) {
        super();
        this._connectionState = enums_1.ConnectionState.Closed;
        this._debug = false;
        this._localPacketId = 1;
        this._maxPacketID = (1 << 15) - 1; // Atem expects 15 not 16 bits before wrapping
        this._port = 9910;
        this._reconnectInterval = 5000;
        this._inFlightTimeout = 30;
        this._maxRetries = 5;
        this._lastReceivedAt = Date.now();
        this._lastReceivedPacketId = 0;
        this._inFlight = [];
        this._ackTimer = new NanoTimer();
        this._hasTimeout = false;
        this._receivedWithoutAck = 0;
        this._lastAcked = 0;
        this._address = options.address || this._address;
        this._port = options.port || this._port;
        this._createSocket();
    }
    connect(address, port) {
        if (!this._reconnectTimer) {
            this._reconnectTimer = setInterval(() => {
                if (this._lastReceivedAt + this._reconnectInterval > Date.now())
                    return;
                if (this._connectionState === enums_1.ConnectionState.Established) {
                    this._connectionState = enums_1.ConnectionState.Closed;
                    this.emit(enums_1.IPCMessageType.Disconnect, null, null);
                }
                this._localPacketId = 1;
                this._sessionId = 0;
                this.log('reconnect');
                if (this._address && this._port) {
                    this._sendPacket(atemUtil_1.Util.COMMAND_CONNECT_HELLO);
                    this._connectionState = enums_1.ConnectionState.SynSent;
                }
            }, this._reconnectInterval);
        }
        // Check for retransmits every 10 milliseconds
        this._retransmitTimer = setInterval(() => this._checkForRetransmit(), 10);
        if (address) {
            this._address = address;
        }
        if (port) {
            this._port = port;
        }
        this._sendPacket(atemUtil_1.Util.COMMAND_CONNECT_HELLO);
        this._connectionState = enums_1.ConnectionState.SynSent;
    }
    disconnect() {
        return new Promise((resolve) => {
            if (this._connectionState === enums_1.ConnectionState.Established) {
                this._socket.close(() => {
                    resolve();
                });
            }
            else {
                resolve();
            }
        }).then(() => {
            clearInterval(this._retransmitTimer);
            clearInterval(this._reconnectTimer);
            this._reconnectTimer = undefined;
            this._connectionState = enums_1.ConnectionState.Closed;
            this._createSocket();
            this.emit(enums_1.IPCMessageType.Disconnect);
        });
    }
    log(...args) {
        const payload = util_1.format.apply(util_1.format, args);
        this.emit(enums_1.IPCMessageType.Log, payload);
    }
    get nextPacketId() {
        return this._localPacketId;
    }
    _sendCommand(serializedCommand, trackingId) {
        const payload = serializedCommand;
        if (this._debug)
            this.log('PAYLOAD', payload);
        const buffer = Buffer.alloc(12 + payload.length, 0);
        buffer.writeUInt16BE(0x0800 | payload.length + 12, 0); // Opcode & Length
        buffer.writeUInt16BE(this._sessionId, 2);
        buffer.writeUInt16BE(this._localPacketId, 10);
        payload.copy(buffer, 12);
        this._sendPacket(buffer);
        this._inFlight.push({
            packetId: this._localPacketId,
            trackingId,
            lastSent: Date.now(),
            packet: buffer,
            resent: 0
        });
        this._localPacketId++;
        if (this._maxPacketID < this._localPacketId)
            this._localPacketId = 0;
    }
    _createSocket() {
        this._socket = dgram_1.createSocket('udp4');
        this._socket.bind();
        this._socket.on('message', (packet, rinfo) => this._receivePacket(packet, rinfo));
    }
    _receivePacket(packet, rinfo) {
        if (this._debug)
            this.log('RECV ', packet);
        this._lastReceivedAt = Date.now();
        const length = ((packet[0] & 0x07) << 8) | packet[1];
        if (length !== rinfo.size)
            return;
        const flags = packet[0] >> 3;
        // this._sessionId = [packet[2], packet[3]]
        this._sessionId = packet[2] << 8 | packet[3];
        const remotePacketId = packet[10] << 8 | packet[11];
        // Send hello answer packet when receive connect flags
        if (flags & enums_1.PacketFlag.Connect && !(flags & enums_1.PacketFlag.Repeat)) {
            this._sendPacket(atemUtil_1.Util.COMMAND_CONNECT_HELLO_ANSWER);
        }
        // Parse commands, Emit 'stateChanged' event after parse
        if (flags & enums_1.PacketFlag.AckRequest) {
            if (this._connectionState === enums_1.ConnectionState.Established) {
                if (remotePacketId === (this._lastReceivedPacketId + 1) % this._maxPacketID) {
                    this._attemptAck(remotePacketId);
                    this._lastReceivedPacketId = remotePacketId;
                }
                else {
                    return;
                }
            }
            if (length > 12) {
                this.emit(enums_1.IPCMessageType.InboundCommand, packet.slice(12), remotePacketId);
            }
        }
        // Send ping packet, Emit 'connect' event after receive all stats
        if (flags & enums_1.PacketFlag.AckRequest && length === 12 && this._connectionState === enums_1.ConnectionState.SynSent) {
            this._connectionState = enums_1.ConnectionState.Established;
            this._sendAck(remotePacketId);
            this._lastReceivedPacketId = remotePacketId;
        }
        // Device ack'ed our command
        if (flags & enums_1.PacketFlag.AckReply && this._connectionState === enums_1.ConnectionState.Established) {
            const ackPacketId = packet[4] << 8 | packet[5];
            this._lastAcked = ackPacketId;
            for (const i in this._inFlight) {
                if (ackPacketId >= this._inFlight[i].packetId || this._localPacketId < this._inFlight[i].packetId) {
                    this.emit(enums_1.IPCMessageType.CommandAcknowledged, this._inFlight[i].packetId, this._inFlight[i].trackingId);
                    this._inFlight.splice(Number(i), 1);
                }
            }
        }
    }
    _sendPacket(packet) {
        if (this._debug)
            this.log('SEND ', packet);
        this._socket.send(packet, 0, packet.length, this._port, this._address);
    }
    _attemptAck(packetId) {
        this._lastReceivedPacketId = packetId;
        this._receivedWithoutAck++;
        if (this._receivedWithoutAck === 16) {
            this._receivedWithoutAck = 0;
            this._hasTimeout = false;
            this._ackTimer.clearTimeout();
            this._sendAck(this._lastReceivedPacketId);
        }
        else if (!this._hasTimeout) {
            this._hasTimeout = true;
            // timeout for 5 ms (syntax for nanotimer says m)
            this._ackTimer.setTimeout(() => {
                this._receivedWithoutAck = 0;
                this._hasTimeout = false;
                this._sendAck(this._lastReceivedPacketId);
            }, [], '5m');
        }
    }
    _sendAck(packetId) {
        const buffer = Buffer.alloc(12, 0);
        buffer.writeUInt16BE(0x800C, 0); // Opcode & Length
        buffer.writeUInt16BE(this._sessionId, 2);
        buffer.writeUInt16BE(packetId, 4);
        buffer.writeUInt8(0x41, 9);
        this._sendPacket(buffer);
    }
    _checkForRetransmit() {
        let retransmitFromPacketId;
        for (const sentPacket of this._inFlight) {
            if (sentPacket.packetId <= this._lastAcked || sentPacket.packetId > this._localPacketId) {
                this.emit(enums_1.IPCMessageType.CommandAcknowledged, sentPacket.packetId, sentPacket.trackingId);
                this._inFlight.splice(this._inFlight.indexOf(sentPacket), 1);
                continue;
            }
            if (retransmitFromPacketId && sentPacket.packetId > retransmitFromPacketId) {
                sentPacket.lastSent = Date.now();
                sentPacket.resent++;
                this._sendPacket(sentPacket.packet);
            }
            else if (sentPacket && sentPacket.lastSent + this._inFlightTimeout < Date.now()) {
                if (sentPacket.resent <= this._maxRetries && sentPacket.packetId < this.nextPacketId) {
                    sentPacket.lastSent = Date.now();
                    sentPacket.resent++;
                    this.log('RESEND: ', sentPacket);
                    this._sendPacket(sentPacket.packet);
                    retransmitFromPacketId = sentPacket.packetId;
                }
                else {
                    this.emit(enums_1.IPCMessageType.CommandTimeout, sentPacket.packetId, sentPacket.trackingId);
                    this._inFlight.splice(this._inFlight.indexOf(sentPacket), 1);
                    this.log('TIMED OUT: ', sentPacket.packet);
                    // @todo: we should probably break up the connection here.
                }
            }
        }
    }
}
exports.AtemSocketChild = AtemSocketChild;
//# sourceMappingURL=atemSocketChild.js.map